" vim: foldmethod=marker

set nocompatible       " Be iMproved
let g:mapleader = ','  " Set <Leader>

" Plugin configuration {{{1

" Download vim-plug if not installed
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif

call plug#begin('~/.vim/plugged')

" Editor enhancements {{{2

" tpope tools {{{3
" Load sensible first, so options can be overridden
Plug 'tpope/vim-sensible'  " sensible config starting point
runtime! plugin/sensible.vim

Plug 'tpope/vim-endwise'   " automatically and wisely close environments
Plug 'tpope/vim-repeat'    " improve `.'
Plug 'tpope/vim-surround'  " play with brackets, quotes etc.
Plug 'tpope/vim-eunuch'    " integrate shell commands like mv, rm etc.

" tcomment {{{3
Plug 'tomtom/tcomment_vim'  " toggle comments
let g:tcomment_mapleader1 = "<C-/>"
let g:tcomment_mapleader2 = "g/"
let g:tcomment#options = {'whitespace' : 'no'}

" loupe {{{3
Plug 'wincent/loupe'  " improve vim search and highlighting
nmap <silent> <Leader><Space> <Plug>(LoupeClearHighlight)

" vim-grepper {{{3
Plug 'mhinz/vim-grepper'  " grep inside vim

if !exists('g:grepper')
  let g:grepper = {}
endif
let g:grepper.highlight = 1
nmap gs <plug>(GrepperOperator)
xmap gs <plug>(GrepperOperator)

" undotree {{{3
Plug 'mbbill/undotree'  " navigate undo tree
nmap <silent> <Leader>u :UndotreeToggle<CR>

" vim-stay {{{3
Plug 'zhimsel/vim-stay'  " don't lose place in buffer

" FastFold {{{3
Plug 'Konfekt/FastFold'  " speed up folds

" ListToggle {{{3
Plug 'Valloric/ListToggle'  " toggle location list and quickfix list
let g:lt_location_list_toggle_map = '<Leader>el'
let g:lt_quickfix_list_toggle_map = '<Leader>eq'

" IDE-like functionality {{{2

" command-t {{{3
" file and buffer name fuzzy search
Plug 'wincent/command-t',
      \ {'do': 'cd ruby/command-t/ext/command-t && ruby extconf.rb && make'}
nmap <silent> <C-T> <Plug>(CommandT)
nmap <silent> <C-B> <Plug>(CommandTBuffer)
nmap <silent> <C-J> <Plug>(CommandTJump)
" tmux compatibility:
if &term =~# "tmux"
  let g:CommandTSelectNextMap = ['<C-N>', '<C-J>', '<Down>', '<ESC>OB']
  let g:CommandTSelectPrevMap = ['<C-P>', '<C-K>', '<Up>', '<ESC>OA']
  let g:CommandTSelectLeftMap = ['<Left>', '<C-H>', '<ESC>OD']
  let g:CommandTSelectRightMap = ['<Right>', '<C-L>', '<ESC>OC']
endif

" dirvish {{{3
Plug 'justinmk/vim-dirvish'            " browse directories and files
Plug 'kristijanhusak/vim-dirvish-git'  " annotate dirvish with git status

" git integration {{{3
Plug 'tpope/vim-fugitive'                 " git status, commit, diff etc.
Plug 'gregsexton/gitv', {'on': ['Gitv']}  " view git history
Plug 'airblade/vim-gitgutter'             " see git diff in gutter, stage hunks
let g:gitgutter_map_keys = 0
nmap <silent> <Leader>gg :Gstatus<CR>
nmap <silent> <Leader>gd :Gdiff<CR>
nmap <silent> <Leader>gv :Gitv<CR>
nmap <silent> <Leader>gV :Gitv!<CR>
nmap <silent> <Leader>gP <Plug>GitGutterPreviewHunk
nmap <silent> <Leader>gs <Plug>GitGutterStageHunk
nmap <silent> <Leader>gu <Plug>GitGutterUndoHunk
nmap <silent> <Leader>gn <Plug>GitGutterNextHunk
nmap <silent> <Leader>gp <Plug>GitGutterPrevHunk

" YouCompleteMe {{{3
" autocomplete
Plug 'Valloric/YouCompleteMe',
      \ {'do': './install.py --clang-completer > ~/ycm.log'}
let g:ycm_goto_buffer_command = 'split-or-existing-window'
let g:ycm_key_detailed_diagnostics = ''

augroup ycm-mappings
  autocmd!
  autocmd FileType
        \ c,cpp,objc,objcpp,cuda,cs,go,java,javascript,python,rust,typescript
        \ nmap <silent> <buffer>go :YcmCompleter GoTo<Cr>
        \ | vmap <silent> <buffer>go :YcmCompleter GoTo<Cr>
  autocmd FileType
        \ c,cpp,objc,objcpp,cuda,cs,java,javascript,python,typescript,rust
        \ nmap <silent> <buffer>K :YcmCompleter GetDoc<Cr>
        \ | vmap <silent> <buffer>K :YcmCompleter GetDoc<Cr>
augroup END

" ALE {{{3
Plug 'w0rp/ale'  " autolint
let g:ale_echo_msg_error_str = 'E'
let g:ale_echo_msg_info_str = 'I'
let g:ale_echo_msg_warning_str = 'W'
let g:ale_echo_msg_format = '%linter% %severity%: %s (%code%)'

" snippets {{{3
Plug 'SirVer/ultisnips'    " snippet engine
Plug 'honza/vim-snippets'  " snippets
let g:UltiSnipsExpandTrigger = '<C-]>'
let g:UltiSnipsJumpForwardTrigger = '<C-]>'
let g:UltiSnipsJumpBackwardTrigger = '<C-[>'

" Tagbar {{{3
Plug 'majutsushi/tagbar'  " browse tags by scope
let g:tagbar_map_showproto = 'd'
let g:tagbar_map_togglefold = ['o', 'za', '<Space>']
nmap <silent> <Leader>' :TagbarToggle<CR>

" vim-slime {{{3
Plug 'jpalardy/vim-slime'  " send text from buffer to terminal process
if &term =~# "tmux"
  let g:slime_target = "tmux"
  let g:slime_default_config = {
        \ "socket_name": split($TMUX, ",")[0],
        \ "target_pane": ":.1"
        \ }
else
  let g:slime_target = "vimterminal"
  let g:slime_vimterminal_config = {"term_finish": "close"}
endif
let g:slime_paste_file = tempname()
let g:slime_python_ipython = 1
let g:slime_no_mappings = 1
nmap <silent> <Plug>NoSlimeParagraphSend <Plug>SlimeParagraphSend
nmap <silent> <Plug>NoSlimeConfig <Plug>SlimeLineSend
nmap <silent> gr <Plug>SlimeMotionSend
nmap <silent> grr <Plug>SlimeLineSend
xmap <silent> gr <Plug>SlimeRegionSend

" Language specific plugins {{{2

" python {{{3
Plug 'tmhedberg/SimpylFold'           " fold python correctly
Plug 'Vimjas/vim-python-pep8-indent'  " indent python correctly

" julia {{{3
Plug '~/packages/julia-vim'    " julia unicode, motions, and docs
Plug 'AtsushiSakai/julia.vim'  " julia linting
let g:latex_to_unicode_tab = 0
let g:latex_to_unicode_eager = 0
"let g:latex_to_unicode_auto = 1
augroup unicode
  autocmd!
  autocmd FileType julia
        \ imap <silent> <buffer> <expr> <C-Y> LaTeXtoUnicode#AutoSub()
augroup END
if !exists('g:ycm_semantic_triggers')
  let g:ycm_semantic_triggers = {}
endif
let g:ycm_semantic_triggers.julia = ['re!\\\S+']

" latex {{{3
Plug 'lervag/vimtex'  " complete, compile, view output, parse errors
let g:vimtex_view_automatic = 0
let g:vimtex_view_method = 'zathura'
let g:vimtex_fold_enabled = 1
let g:vimtex_complete_enabled = 1
let g:vimtex_complete_close_braces = 0
"let g:vimtex_quickfix_latexlog = {
"      \ 'overfull' : 0,
"      \ 'underfull' : 0,
"      \ 'packages' : {
"      \   'default' : 0,
"      \ },
"      \}

" Display options: colorschemes, status lines etc. {{{2

" vim-airline {{{3
Plug 'vim-airline/vim-airline'         " improved status line and buffer line
Plug 'vim-airline/vim-airline-themes'  " colorscheme-specific line themes
let g:airline#extensions#tabline#enabled = 1

" base16 {{{3
Plug 'chriskempson/base16-vim'  " base16 colorschemes

" Currently unused plugins {{{2

"" CCTree {{{3
"" build and show call tree in C
"Plug 'hari-rangarajan/CCTree', \ {'for': ['c', 'cpp', 'java']}

"" solarized {{{3
"Plug 'altercation/vim-colors-solarized'  " solarized colorscheme

" }}}2

call plug#end()

" Post-plug configuration {{{1

" vim-stay {{{2
set viewoptions=cursor,slash,unix

" latex {{{2
if !exists('g:ycm_semantic_triggers')
  let g:ycm_semantic_triggers = {}
endif
let g:ycm_semantic_triggers.tex = g:vimtex#re#youcompleteme

" base16 {{{2
let s:base16_config_file = expand("~/.vimrc_background")
if !has('gui_running')
  if filereadable(s:base16_config_file)
    let g:base16colorspace = 256
    execute 'source ' . s:base16_config_file
    let g:airline_theme = 'base16_shell'
  else
    set termguicolors
    colorscheme base16-ocean
    let g:airline_theme = 'base16_ocean'
  endif
else
  colorscheme base16-solarized-light
endif

"" solarized {{{2
"colorscheme solarized
"call togglebg#map("<F5>")
"let g:airline_theme = 'solarized'

" General settings {{{1

set autowrite            " Save before commands like :next and :make
set hidden               " Keep abandoned buffers around in the background
set showcmd              " Show number of selected lines ++ in the bottom line
set noswapfile           " Do not use swap file
set wildmode=list:longest " Set autocomplete command behavior
set completeopt=menuone,preview " Set completion options
set mouse=a              " Enable mouse usage (all modes)

" Enable persistent undo
set undofile
set undolevels=1000
set undoreload=10000
set undodir=$HOME/.vim/undo
if !isdirectory(&undodir)
  call mkdir(&undodir)
endif

" Editing behavior
set copyindent           " Don't replace tabs with spaces when copying indent
set preserveindent       " Don't replace tabs with spaces when adjusting indent
set expandtab            " Expand tabs as spaces
set shiftwidth=4         " Set width of autoindentation
set textwidth=79         " Auto-format, e.g., gq, wraps here (0: disable)
set nojoinspaces         " Don't have <S-J> (joining) insert double spaces.
set formatoptions=cql1j  " Set auto-format options
augroup autoformat       " Bring out the big guns to override ftplugins
  autocmd!
  autocmd FileType * set fo-=r fo-=o
augroup END


" Search behavior
set ignorecase           " Do case insensitive matching
set smartcase            " Do smart case matching
set hlsearch             " Highlight search

" Always start a server
if empty(v:servername) && exists('*remote_startserver')
  call remote_startserver('VIM')
endif

" Display settings {{{1

set nowrap               " Do not wrap lines for display
set linebreak            " If turning wrap back on, wrap at a whitespace
set relativenumber       " Show relative line numbers
set number               " Show line numbers (relative + absolute => hybrid)
set colorcolumn=+1,+2,+3 " Highlight columns after textwidth
set showmatch            " Show matching brackets.
set tabstop=4            " Set width of tabstops

" Set whitespace characters in list mode
set listchars=eol:$,tab:\|\ ,trail:-,space:.,extends:>,precedes:<,conceal:*,nbsp:~

" Configure defaults for built-in terminal
set termwinsize=6x0
augroup terminal
  autocmd!
  " Terminal has absolutely no business on the buffer list
  autocmd TerminalOpen * setlocal nobuflisted
augroup END

" Set gui specific options
if has('vim_starting') && has('gui_running')
  set guifont=Noto\ Mono\ 11
  set guioptions+=f        " Dont detach from shell
  set guioptions+=P        " Enable autoselect using the "+-register
  set guioptions-=a        " Disable autoselect using the "*-register
  set guioptions-=T        " Disable toolbar
  set guioptions-=m        " Disable menubar
  set guioptions-=r        " Disable scrollbar
endif

" Key mappings and commands {{{1

" Scroll screen-based instead of line-based
nnoremap k gk
vnoremap k gk
nnoremap j gj
vnoremap j gj
nnoremap gk k
vnoremap gk k
nnoremap gj j
vnoremap gj j

" Navigate windows easily; <Leader> as <C-W>. See :h opening-window.
nnoremap <Leader> <C-W>

" Navigate buffers easily
function! <SID>Bufgo(bang, bufindex, args)
  execute a:bufindex . 'buffer' . a:bang a:args
endfunction

function! <SID>SplitBufgo(bang, bufindex, args)
  execute a:bufindex . 'sbuffer' . a:bang a:args
endfunction

function! <SID>Buflast()
  return <SID>BufNFromIndexWithRef(0, -1, bufnr("$"), bufnr('%'))
endfunction

function! <SID>Buffirst()
  return <SID>BufNFromIndexWithRef(0, 1, 1, bufnr('%'))
endfunction

function! <SID>Bufnext(N)
  return <SID>BufNFromIndexWithRef(a:N, 1, bufnr("%"), bufnr('%'))
endfunction

function! <SID>Bufprev(N)
  return <SID>BufNFromIndexWithRef(a:N, -1, bufnr("%"), bufnr('%'))
endfunction

function! <SID>BufNFromIndexWithRef(N, direction, bufindex, refindex)
  if <SID>Validbuf(a:refindex)
    return <SID>BufNFromIndex(
          \ a:N, a:direction, a:bufindex, getbufvar(a:refindex, '&buftype'))
  endif
  return a:refindex
endfunction

function! <SID>BufNFromIndex(N, direction, bufindex, type)
  let lastbuf = bufnr('$')
  let i = -1
  let newindex = a:bufindex
  if <SID>Validbuf(newindex, a:type)
    let i += 1
  endif
  while i < a:N
    let newindex = <SID>Wraparound(newindex + a:direction, lastbuf)
    if <SID>Validbuf(newindex, a:type)
      let i += 1
    elseif newindex == a:bufindex && i == -1
      return -1
    endif
  endwhile
  return newindex
endfunction

function! <SID>Validbuf(bufindex, ...)
  if bufexists(a:bufindex)
    let btype = getbufvar(a:bufindex, '&buftype')
    if a:0 > 0 && a:1 !=# btype
        return 0
    elseif btype ==# ''
      return buflisted(a:bufindex)
    elseif btype ==# 'help'
      return !buflisted(a:bufindex)
    endif
  endif
  return 0
endfunction

function! <SID>Wraparound(index, length)
  return (a:index + a:length - 1) % a:length + 1
endfunction

function! <SID>Bufremove(cmd, bang, range, line1, line2, ...)
  if a:0 > 0
    if a:range > 0
      " Inconsistent arguments, give up
      let buflist = []
    else
      let buflist = copy(a:000)
    endif
  elseif a:range == 2
    let buflist = range(a:line1, a:line2)
  else
    let buflist = [a:line1]
  endif
  call map(buflist, function('<SID>BufindexMap'))
  call filter(buflist, function('<SID>BufindexFilter'))
  if len(buflist) == 0
    let verb = <SID>BufremoveVerb(a:cmd)
    echohl ErrorMsg
    echomsg "No buffers were" verb
    echohl None
    return
  endif
  for bufindex in buflist
    call <SID>BufremoveIndex(a:cmd, a:bang, bufindex)
  endfor
endfunction

function! <SID>BufremoveIndex(cmd, bang, bufindex)
  " Try to switch buffer in all windows where buffer to remove is open
  let thiswinid = win_getid(winnr())
  for winid in win_findbuf(a:bufindex)
    call win_gotoid(winid)
    call <SID>Bufgo(a:bang, <SID>Bufprev(1), '')
  endfor
  call win_gotoid(thiswinid)
  " Buffer might have self-destructed upon being hidden
  if <SID>Bufremovable(a:cmd, a:bufindex)
    execute a:bufindex . a:cmd . a:bang
  endif
endfunction

function! <SID>BufindexMap(_, str)
  if <SID>StringIsNr(a:str)
    return bufnr(str2nr(a:str))
  else
    return bufnr(a:str)
  endif
endfunction

function! <SID>BufindexFilter(_, bufindex)
  if a:bufindex == -1
    return 0
  endif
  return 1
endfunction

function! <SID>StringIsNr(str)
  return (a:str =~# '\m^\d\+$')
endfunction

function! <SID>BufremoveVerb(cmd)
  if a:cmd =~# 'bw'
    return "wiped out"
  elseif a:cmd =~# 'bd'
    return "deleted"
  elseif a:cmd =~# 'bun'
    return "unloaded"
  endif
  return "removed"
endfunction

function! <SID>Bufremovable(cmd, bufindex)
  if bufexists(a:bufindex)
    if a:cmd =~# 'bw'
      return 1
    else
      let loaded = bufloaded(a:bufindex)
      let listed = buflisted(a:bufindex)
      if a:cmd =~# 'bd'
        return (loaded || listed)
      elseif a:cmd =~# 'bun'
        return loaded
      endif
    endif
  endif
  return 0
endfunction

command! -nargs=* -bang Blast
      \ call <SID>Bufgo('<bang>', <SID>Buflast(), <q-args>)
command! -nargs=* -bang SBlast
      \ call <SID>SplitBufgo('<bang>', <SID>Buflast(), <q-args>)
command! -nargs=* -bang Bfirst
      \ call <SID>Bufgo('<bang>', <SID>Buffirst(), <q-args>)
command! -nargs=* -bang SBfirst
      \ call <SID>SplitBufgo('<bang>', <SID>Buffirst(), <q-args>)
command! -nargs=* -bang Brewind Bfirst<bang> <q-args>
command! -nargs=* -bang SBrewind SBfirst<bang> <q-args>
command! -nargs=* -range=1 -bang Bnext
      \ call <SID>Bufgo('<bang>', <SID>Bufnext(<count>), <q-args>)
command! -nargs=* -range=1 -bang SBnext
      \ call <SID>SplitBufgo('<bang>', <SID>Bufnext(<count>), <q-args>)
command! -nargs=* -range=1 -bang Bprev
      \ call <SID>Bufgo('<bang>', <SID>Bufprev(<count>), <q-args>)
command! -nargs=* -range=1 -bang SBprev
      \ call <SID>SplitBufgo('<bang>', <SID>Bufprev(<count>), <q-args>)
command! -nargs=* -range=1 -bang BNext <count>Bprev<bang> <q-args>
command! -nargs=* -range=1 -bang SBNext <count>SBprev<bang> <q-args>
command! -nargs=* -complete=buffer -range -addr=buffers -bang Bdelete
      \ call <SID>Bufremove(
      \ 'bdelete', '<bang>', <range>, <line1>, <line2>, <f-args>)
command! -nargs=* -complete=buffer -range -addr=buffers -bang Bwipeout
      \ call <SID>Bufremove(
      \ 'bwipeout', '<bang>', <range>, <line1>, <line2>, <f-args>)
command! -nargs=* -complete=buffer -range -addr=buffers -bang Bunload
      \ call <SID>Bufremove(
      \ 'bunload', '<bang>', <range>, <line1>, <line2>, <f-args>)

nmap <silent> <Down> :Blast<CR>
nmap <silent> <Up> :Bfirst<CR>
nmap <silent> <Left> :Bprev<CR>
nmap <silent> <Right> :Bnext<CR>
nmap <silent> <C-C> :Bdelete<CR>

" Define a command that opens a file like :drop, but splits the window if the
" buffer in focus is of a special buftype to avoid displacing it.
function! <SID>Drop(args)
  let bufindex = bufnr('%')
  let btype = getbufvar(bufindex, '&buftype')
  let special = (btype !=# "")
  if special
    " Trick vim into refusing to abandon the buffer in focus
    let hid = getbufvar(bufindex, '&hidden')
    let mod = getbufvar(bufindex, '&modified')
    call setbufvar(bufindex, '&hidden', 0)
    call setbufvar(bufindex, '&buftype', "")
    call setbufvar(bufindex, '&modified', 1)
  endif
  execute 'drop' a:args
  if special
    " Reset buffer options
    call setbufvar(bufindex, '&modified', mod)
    call setbufvar(bufindex, '&buftype', btype)
    call setbufvar(bufindex, '&hidden', hid)
  endif
endfunction

command! -nargs=+ -complete=file Drop call <SID>Drop(<q-args>)

" Hit <Leader>, to Drop $MYVIMRC, and <Leader>. to source
nmap <silent> <Leader>, :Drop $MYVIMRC<CR>
if has('gui_running') && filereadable($MYGVIMRC)
    nmap <silent> <Leader>. :source $MYVIMRC<CR>:source $MYGVIMRC<CR>
else
    nmap <silent> <Leader>. :source $MYVIMRC<CR>
endif

" Toggle folds with <Space>
nnoremap <expr> <Space>
      \ foldlevel('.') ?
      \ 'za' :
      \ "\<Space>"

" Hit <Leader>/ to toggle list mode
nmap <silent> <Leader>\ :set list!<CR>

" Change the (local) directory to that of current file with :Cd (:Lcd)
command! Cd cd %:h
command! Lcd lcd %:h

" Available unmodified keys to follow leader: imy;/[]0123456789`

" File/buffer/window type specific settings {{{1

" tex {{{2
"let g:tex_flavor = 'latex'  " Let's see if leaving this out works

augroup tex
  autocmd!
  autocmd FileType tex,bib setlocal tabstop=2 shiftwidth=2 textwidth=0 wrap
        \ breakindent breakindentopt=shift:2
  autocmd FileType tex setlocal spell
augroup END

" lilypond {{{2
let g:lilypond_vim_dir = split(expand('/usr/share/lilypond/*/vim/'))[-1]
if isdirectory(g:lilypond_vim_dir)
  filetype off
  set rtp+=g:lilypond_vim_dir
  filetype on
endif

augroup lilypond
  autocmd!
  autocmd FileType lilypond setlocal tabstop=2 shiftwidth=2
  autocmd FileType lilypond
        \ nmap <silent> <buffer> <LocalLeader>ly :!lilypond %<CR>
augroup END

" gitcommit {{{2
augroup gitcommit
  autocmd!
  autocmd FileType gitcommit setlocal spell textwidth=72 formatoptions+=t
augroup END

" script languages {{{2
augroup scripts
  autocmd!
  autocmd FileType vim,javascript,typescript setlocal tabstop=2 shiftwidth=2
augroup END

" c-family {{{2
augroup c_family
  autocmd!
  autocmd FileType c,cpp,objc,objcpp,cuda,cs,go,java setlocal cindent
        \ cinoptions=(0,u0 noexpandtab tabstop=8 shiftwidth=8 foldmethod=syntax
        \ foldnestmax=2
augroup END

" special windows or buffers {{{2
function! <SID>BufferOrWindowIsSpecial()
  return (&buftype !=# "" || &previewwindow)
endfunction

augroup special
  autocmd!
  autocmd BufWinEnter *
        \ if <SID>BufferOrWindowIsSpecial()
        \ | setlocal textwidth=0
        \ | endif
augroup END
