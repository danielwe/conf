" vim: foldmethod=marker

set nocompatible       " Be iMproved
let g:mapleader = ','  " Set <Leader>
if has('win32')
  let $MYVIMRUNTIME = expand('$HOME/vimfiles')
else
  let $MYVIMRUNTIME = expand('$HOME/.vim')
endif

" Plugin configuration {{{1

" Download vim-plug if not installed
let s:plugpath = expand($MYVIMRUNTIME . '/autoload/plug.vim')
if empty(glob(s:plugpath))
  execute "silent !curl -fLo" s:plugpath "--create-dirs"
    \ "https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim"
  autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif
unlet s:plugpath

" Plugin development support
function! s:DevelopOrPlug(name)
  let l:devpath = expand('$HOME/packages/' . a:name)
  if isdirectory(l:devpath)
    Plug l:devpath
  else
    Plug 'danielwe/' . a:name
  endif
endfunction

call plug#begin()

" Editor enhancements {{{2

" tpope tools {{{3
Plug 'tpope/vim-sensible'     " sensible config starting point
Plug 'tpope/vim-endwise'      " automatically and wisely close environments
Plug 'tpope/vim-repeat'       " improve `.'
Plug 'tpope/vim-surround'     " play with brackets, quotes etc.
Plug 'tpope/vim-eunuch'       " integrate shell commands like mv, rm etc.
Plug 'tpope/vim-unimpaired'   " nifty keymappings, learn to use!

" vim-butter {{{3
call s:DevelopOrPlug('vim-butter')  " smoothen buffer navigation
nmap <silent> <Down> :Blast<CR>
nmap <silent> <Up> :Bfirst<CR>
nmap <silent> <Left> :Bprev<CR>
nmap <silent> <Right> :Bnext<CR>
nmap <silent> <C-C> :Bdelete<CR>

" tcomment {{{3
Plug 'tomtom/tcomment_vim'  " toggle comments
let g:tcomment_mapleader1 = "<C-/>"
let g:tcomment_mapleader2 = "g/"
let g:tcomment#options = {'whitespace' : 'yes'}

" loupe {{{3
Plug 'wincent/loupe'  " improve search and highlighting
nmap <silent> <Leader>/ <Plug>(LoupeClearHighlight)

" undotree {{{3
Plug 'mbbill/undotree'  " navigate undo tree
nmap <silent> <Leader>u :UndotreeToggle<CR>

" vim-stay {{{3
Plug 'zhimsel/vim-stay'  " keep place in buffer across sessions

" FastFold {{{3
Plug 'Konfekt/FastFold'  " speed up folds

" ListToggle {{{3
Plug 'Valloric/ListToggle'  " toggle location list and quickfix list
"call s:DevelopOrPlug('ListToggle')
let g:lt_quickfix_list_toggle_map = '<Leader>qq'
let g:lt_location_list_toggle_map = '<Leader>ql'

" custom text objects {{{3
Plug 'kana/vim-textobj-user'    " define custom text objects
Plug 'kana/vim-textobj-entire'  " define text objects for the entire buffer

" IDE-like functionality {{{2

" command-t/ctrlp fuzzy finder {{{3
if has('ruby')
  Plug 'wincent/command-t',
        \ {'do': 'cd ruby/command-t/ext/command-t && ruby extconf.rb && make'}
  nmap <silent> <Leader>ff <Plug>(CommandT)
  nmap <silent> <Leader>fb <Plug>(CommandTBuffer)
  nmap <silent> <Leader>fj <Plug>(CommandTJump)
  nmap <silent> <Leader>fh <Plug>(CommandTHelp)
  " terminal compatibility: the tale of arrow keys and esc
  if (&term =~# "xterm") || (&term =~# "tmux")
    " esc is not mapped by default in xterm, let's fix that
    " (not actually needed for tmux, but doesn't hurt)
    let g:CommandTCancelMap = ['<C-C>', '<ESC>']
    " now esc is mapped and arrow keys will misbehave, let's fix that
    let g:CommandTSelectNextMap = ['<C-N>', '<C-J>', '<Down>', '<ESC>OB']
    let g:CommandTSelectPrevMap = ['<C-P>', '<C-K>', '<Up>', '<ESC>OA']
    let g:CommandTSelectLeftMap = ['<Left>', '<C-H>', '<ESC>OD']
    let g:CommandTSelectRightMap = ['<Right>', '<C-L>', '<ESC>OC']
  endif
else
  Plug 'ctrlpvim/ctrlp.vim'
  let g:ctrlp_map = '<Leader>ff'
  nmap <silent> <Leader>fb :CtrlPBuffer<CR>
endif

" vim-grepper {{{3
Plug 'mhinz/vim-grepper'  " grep from vim
nmap <Leader>s <plug>(GrepperOperator)
xmap <Leader>s <plug>(GrepperOperator)

" dirvish {{{3
Plug 'justinmk/vim-dirvish'              " browse directories and files
if v:version >= 800
  Plug 'kristijanhusak/vim-dirvish-git'  " annotate dirvish with git status
endif

" git integration {{{3
Plug 'tpope/vim-fugitive'                 " git status, commit, diff etc.
Plug 'gregsexton/gitv', {'on': ['Gitv']}  " view git history
Plug 'airblade/vim-gitgutter'             " see git diff in gutter, stage hunks
let g:gitgutter_map_keys = 0
nmap <silent> <Leader>gg :Gstatus<CR>
nmap <silent> <Leader>gd :Gdiff<CR>
nmap <silent> <Leader>gl :Gitv<CR>
nmap <silent> <Leader>gf :Gitv!<CR>
nmap <silent> <Leader>gh <Plug>GitGutterPreviewHunk
nmap <silent> <Leader>gs <Plug>GitGutterStageHunk
nmap <silent> <Leader>gu <Plug>GitGutterUndoHunk
nmap <silent> <Leader>gn <Plug>GitGutterNextHunk
nmap <silent> <Leader>gp <Plug>GitGutterPrevHunk

" YouCompleteMe {{{3
if has('win32')
  let g:system_python = 'py -3'
else
  let g:system_python = '/usr/bin/python3'
endif
Plug 'Valloric/YouCompleteMe', {
      \ 'do':
      \ g:system_python
      \ . ' install.py --clang-completer > ' . expand('$HOME/ycm.log') . ' 2>&1'
      \ }
unlet g:system_python
let g:ycm_python_binary_path = "python"
let g:ycm_key_detailed_diagnostics = ''
let g:ycm_goto_filetypes = [
      \ 'c',
      \ 'cpp',
      \ 'objc',
      \ 'objcpp',
      \ 'cuda',
      \ 'cs',
      \ 'go',
      \ 'java',
      \ 'javascript',
      \ 'python',
      \ 'rust',
      \ 'typescript',
      \ ]
let g:ycm_getdoc_filetypes = [
      \ 'c',
      \ 'cpp',
      \ 'objc',
      \ 'objcpp',
      \ 'cuda',
      \ 'cs',
      \ 'java',
      \ 'javascript',
      \ 'python',
      \ 'typescript',
      \ 'rust',
      \ ]
augroup GoTo
  execute "autocmd! FileType" join(g:ycm_goto_filetypes, ",")
        \ "map <silent> <buffer> <C-]> :YcmCompleter GoTo<Cr>"
augroup END
augroup GetDoc
  execute "autocmd! FileType" join(g:ycm_getdoc_filetypes, ",")
        \ "map <silent> <buffer> K :YcmCompleter GetDoc<Cr>"
augroup END

" ale/syntastic linter {{{3
if v:version >= 800 && (has("patch-8.0.1476") || !has("patch-8.0.1449"))
  " see https://github.com/w0rp/ale/issues/1536 for details about bug and required patch
  Plug 'w0rp/ale'
  "call s:DevelopOrPlug('ale')
  let g:ale_echo_msg_error_str = 'E'
  let g:ale_echo_msg_info_str = 'I'
  let g:ale_echo_msg_warning_str = 'W'
  let g:ale_echo_msg_format = '%linter% %severity%: %s (%code%)'

  " Configure LSP for supported filetypes
  let g:ale_completion_enabled = 1
  let g:ale_lsp_filetypes = ['julia']
  let s:ale_lsp_filetype_pattern = join(g:ale_lsp_filetypes, ",")
  augroup GoTo
    execute "autocmd! FileType" s:ale_lsp_filetype_pattern
          \ "noremap <silent> <buffer> <C-]> <Plug>(ale_go_to_definition)"
  augroup END
  augroup GetDoc
    execute "autocmd! FileType" s:ale_lsp_filetype_pattern
          \ "noremap <silent> <buffer> K <Plug>(ale_hover)"
  augroup END
  unlet s:ale_lsp_filetype_pattern

else
  Plug 'vim-syntastic/syntastic'
  let g:syntastic_always_populate_loc_list = 1
  let g:syntastic_auto_loc_list = 0
  let g:syntastic_check_on_open = 1
  let g:syntastic_check_on_wq = 0
endif

" snippets {{{3
Plug 'SirVer/ultisnips'                       " snippet engine
Plug 'honza/vim-snippets'                     " snippets
" call s:DevelopOrPlug('vim-unicode-snippets')  " unicode snippets with latex triggers
let g:UltiSnipsExpandTrigger = '<C-J>'
let g:UltiSnipsJumpForwardTrigger = '<C-J>'
let g:UltiSnipsJumpBackwardTrigger = '<C-K>'

" Tagbar {{{3
Plug 'majutsushi/tagbar'  " browse tags by scope
let g:tagbar_map_showproto = 'd'
let g:tagbar_map_togglefold = ['o', 'za', '<Space>']
nmap <silent> <Leader>t :TagbarToggle<CR>

" vim-slime {{{3
Plug 'jpalardy/vim-slime'  " send text from buffer to terminal process
let g:slime_no_mappings = 1
nmap <silent> <Leader>r <Plug>SlimeMotionSend
nmap <silent> <Leader>rr <Plug>SlimeLineSend
nmap <silent> <Leader>r<Leader>r <Leader>rr
xmap <silent> <Leader>r <Plug>SlimeRegionSend
if &term =~# "tmux"
  let g:slime_target = "tmux"
  let g:slime_default_config = {
        \ "socket_name": split($TMUX, ",")[0],
        \ "target_pane": ":.1"
        \ }
else
  let g:slime_target = "vimterminal"
  let g:slime_vimterminal_config = {"term_finish": "close"}
endif
let g:slime_paste_file = tempname()
let g:slime_python_ipython = 1

" Language specific plugins {{{2

" python {{{3
Plug 'tmhedberg/SimpylFold'           " fold python correctly
Plug 'Vimjas/vim-python-pep8-indent'  " indent python correctly
if has('python3')
  function! s:PythonVersionMinor()
python3 << EOF
import sys, vim
vim.command("let l:py_version_minor = {}".format(sys.version_info.minor))
EOF
    return l:py_version_minor
  endfunction
  if s:PythonVersionMinor() >= 6
    Plug 'ambv/black'                 " format code
  endif
endif
let g:syntastic_python_checkers = ['pycodestyle', 'pyflakes', 'pylint']

" julia {{{3
Plug 'JuliaEditorSupport/julia-vim'  " julia syntax, motions and docs
"call s:DevelopOrPlug('julia-vim')
let g:latex_to_unicode_tab = 0       " use snippets for unicode
augroup GetDoc
  " Clear any GetDoc binding for julia from ycm/ale; julia-vim does it better by setting
  " the juliadoc filetype, and uses 'keywordprg' so doesn't need explicit binding.
  autocmd! FileType julia
augroup END

" latex {{{3
Plug 'Konfekt/tex-conceal.vim'  " fix tex conceal
let g:tex_conceal = "abdmg"

Plug 'lervag/vimtex'  " complete, compile, view output, parse errors
let g:vimtex_fold_enabled = 1
let g:vimtex_format_enabled = 1
let g:vimtex_view_method = 'zathura'
let g:vimtex_view_automatic = 0
" let g:vimtex_complete_close_braces = 0
" let g:vimtex_quickfix_latexlog = {
"       \ 'overfull' : 0,
"       \ 'underfull' : 0,
"       \ 'packages' : {
"       \   'default' : 0,
"       \ },
"       \}

" markdown etc. {{{3
Plug 'vim-pandoc/vim-pandoc'
Plug 'vim-pandoc/vim-pandoc-syntax'

" toml {{{3
Plug 'cespare/vim-toml'  " add toml syntax

" lilypond {{{3
if !has('win32')
  let s:lilypond_vim_dir = split(expand('/usr/share/lilypond/*/vim/'))[-1]
  if isdirectory(s:lilypond_vim_dir)
    let g:lilypond_enabled = 1
    set rtp+=s:lilypond_vim_dir
  endif
  unlet s:lilypond_vim_dir
endif

" Display options: colorschemes, status lines etc. {{{2

" vim-airline {{{3
Plug 'vim-airline/vim-airline'
"call s:DevelopOrPlug('vim-airline')
Plug 'vim-airline/vim-airline-themes'
"call s:DevelopOrPlug('vim-airline-themes')
let g:airline#extensions#tabline#enabled = 1

" base16 {{{3
"Plug 'chriskempson/base16-vim'  " base16 colorschemes
call s:DevelopOrPlug('base16-vim')

" Colorizer {{{3
Plug 'chrisbra/Colorizer'  " apply color to rgb sequences

" Currently unused plugins {{{2

"" CCTree {{{3
"Plug 'hari-rangarajan/CCTree', {'for': ['c', 'cpp', 'java']}  " show C call tree

"" LanguageClient {{{3
"if v:version >= 800
"  Plug 'autozimu/LanguageClient-neovim', {'branch': 'next', 'do': 'bash install.sh'}
"  let g:LanguageClient_hoverPreview = "always"
"  let g:LanguageClient_diagnosticsList = "location"
"  let g:LanguageClient_selectionUI = "quickfix"
"endif


"" julia {{{3
"Plug 'AtsushiSakai/julia.vim'  " julia linter

"" solarized {{{3
"Plug 'altercation/vim-colors-solarized'

" }}}2

call plug#end()


" Post-plug configuration {{{1

" tpope tools {{{2
if has('vim_starting')
  runtime! plugin/sensible.vim  " load first so options can be overridden
endif

" vim-stay {{{2
execute "set viewdir=" . expand('$MYVIMRUNTIME/view')
set viewoptions=cursor,slash,unix

" vim-grepper {{{2
if has('vim_starting')
  runtime! plugin/grepper.vim  " load now so options can be overridden
endif
let g:grepper.highlight = 1
let g:grepper.git.grepprg .= ' --untracked'

" ale/syntastic linter {{{2
if exists('g:ale_lsp_filetypes')
  if !exists('g:ycm_filetype_blacklist')
    let g:ycm_filetype_blacklist = {}
  endif
  for s:ft in g:ale_lsp_filetypes
    let g:ycm_filetype_blacklist[s:ft] = 1
  endfor
  unlet s:ft
endif

" latex {{{2
if !exists('g:ycm_semantic_triggers')
  let g:ycm_semantic_triggers = {}
endif
let g:ycm_semantic_triggers.tex = g:vimtex#re#youcompleteme

" base16 {{{2
let g:airline_theme = 'base16_vim'
let g:airline_base16_monotone = 1

" The base16 themes seem to work best with background=light. This setting mainly affects
" how vim selects highlighting colors from the palette.
set background=light

" Choose colorscheme. If running in a terminal and termguicolors is not set, any base16
" theme is equivalent, and will give you the base16 theme that the terminal was set up
" with using base16_shell (in particular, the .vimrc_background file from base16_shell
" is unneccesary). In gvim, or with termguicolors set, the theme named below is used.
let s:base16_theme = "base16-atelier-estuary-light"

if ($BASE16_THEME ==# "") && has('termguicolors')
  set termguicolors
else
  if has('gui_running')
    " Don't let a gvim :terminal pretend that it provides a 21-color base16 palette,
    " just because gvim was started from a shell with an active base16 theme. The gvim
    " terminal only provides the terminal_ansi_colors palette.
    let $BASE16_THEME = ""
  else
    if has('termguicolors')
      set notermguicolors
    endif
    let g:base16colorspace = 256
  endif
endif
execute "colorscheme" s:base16_theme
unlet s:base16_theme

"" solarized {{{2
"colorscheme solarized
"call togglebg#map("<F5>")
"let g:airline_theme = 'solarized'

" General settings {{{1

set encoding=utf-8
set hidden                                " Keep abandoned buffers in the background.
set showcmd                               " Show partial commands in the status area.
set wildmode=longest:full,full            " Set autocomplete command behavior.
set completeopt=menuone,preview,noselect  " Set completion options.
set mouse=a                               " Enable mouse in terminal (all modes).

" Enable persistent undo
set undofile
set undolevels=1000
set undoreload=10000
execute "set undodir=" . expand('$MYVIMRUNTIME/undo')
if !isdirectory(&undodir)
  call mkdir(&undodir)
endif

" Editing behavior
set textwidth=88          " Set default line length. Inspired by black.
set shiftwidth=4          " Set default indentation unit.
set expandtab             " Expand tabs as spaces by default.
set autoindent            " Copy indent from previous line when creating new line.
set copyindent            " Mimic indent structure (tabs/spaces) when doing the above.
set preserveindent        " Mimic existing indent structure when manually adjusting.
set nojoinspaces          " Don't have <S-J> (joining) insert double spaces.
set formatoptions=cql1j   " Set auto-format options.
augroup rc_formatoptions  " Bring out the big guns to override ftplugins.
  autocmd! FileType * setlocal fo-=r fo-=o
augroup END


" Search behavior
set ignorecase            " Do case insensitive matching.
set smartcase             " Do smart case matching.
set hlsearch              " Highlight search.

" Start a server
if has('clientserver') && empty(v:servername)
  call remote_startserver('VIM')
endif

" Display settings {{{1

set tabstop=8
set nowrap                " Do not wrap lines for display.
set linebreak             " If turning wrap back on, wrap at a whitespace.
set numberwidth=2         " Set minimum width of line number column.
set norelativenumber      " Show relative line numbers?
set nonumber              " Show line numbers? (relative & absolute => hybrid)
set colorcolumn=+1,+2,+3  " Highlight columns after textwidth.
set showmatch             " Show matching brackets.
set conceallevel=2        " Enable conceal when defined

" Set whitespace characters in list mode
set listchars=eol:$,tab:\|_,space:.,extends:>,precedes:<,conceal:*,nbsp:~

" Set gui specific options
if has('vim_starting') && has('gui_running')
  if !has('win32')
    set guifont=Ubuntu\ Mono\ 12
  endif
  set guioptions+=f       " Dont detach from shell.
  set guioptions+=P       " Enable autoselect using the "+-register.
  set guioptions-=a       " Disable autoselect using the "*-register.
  set guioptions-=T       " Disable toolbar.
  set guioptions-=m       " Disable menubar.
  set guioptions-=r       " Disable scrollbar.
endif

" Terminal color hack for gvim and tmux (see |terminal-unix|---the problem is the
" nonsensical fallbacks)
if has('gui_running')
  let $TERM = 'xterm-256color'
elseif &term =~# '256color'  " e.g., tmux-256color
  " This is experimental: could lead vim to misunderstand some keys. Seems to work fine
  " in tmux, however.
  set term=xterm-256color
endif

" Key mappings and commands {{{1

" Scroll screen-based instead of line-based
noremap k gk
noremap j gj
noremap gk k
noremap gj j
noremap $ g$
noremap ^ g^
noremap g$ $
noremap g^ ^

" Navigate windows easily: map ; to <C-W> (see :h CTRL-W)
nnoremap ; <C-W>

" Toggle folds with <Space>
nnoremap <expr> <Space> foldlevel('.') ? 'za' : '\<Space>'

" Hit <Leader><Space> to toggle list mode
nmap <silent> <Leader><Space> :set list!<CR>

" Hit <Leader>, to Drop $MYVIMRC, and <Leader>. to source it and reload current buffer
nmap <silent> <Leader>, :Drop $MYVIMRC<CR>
if !exists('*<SID>LoadRc')
  function! <SID>LoadRc()
    source $MYVIMRC
    if has('gui_running') && filereadable($MYGVIMRC)
       source $MYGVIMRC
    endif
    silent! edit
  endfunction
endif
nmap <silent> <Leader>. :call <SID>LoadRc()<CR>

" Enable mouse scrolling in vim terminal
function! ExitTerminalNormal()
  nunmap <buffer> <silent> <RightMouse>
  call feedkeys("i")
endfunction

function! MapExitTerminalNormal()
  nmap <buffer> <silent> <RightMouse> :call ExitTerminalNormal()<CR>
endfunction

if has('terminal')
  tmap <silent> <ScrollWheelUp> <C-W>N<C-Y>:call MapExitTerminalNormal()<CR>
  tmap <silent> <ScrollWheelDown> <C-W>N<C-E>:call MapExitTerminalNormal()<CR>
endif

" Change the (local) directory to that of current file with :Cd (:Lcd)
command! Cd cd %:h
command! Lcd lcd %:h

" Available unmodified keys after ;: aemuy,'\/[0123456789`<Space>

" Filetype-specific configuration {{{1

" wrap {{{2
augroup rc_wrap
  " For unwrapped prose, wrap long lines and indicate with a hanging indent (don't apply
  " to, e.g., markdown and help, since these typically contain structures like tables
  " and hard-wrapped columns that don't mix with soft wrapping at all). Do the same when
  " a nonexistent file is opened in a preview window (this is a common mechanism for
  " displaying documentation).
  let s:setprosewrap = "setlocal textwidth=0 wrap breakindent breakindentopt=shift:2"
  execute "autocmd! FileType text,tex,bib" s:setprosewrap
  execute "autocmd! BufNewFile * if &previewwindow |" s:setprosewrap "| endif"
  unlet s:setprosewrap
  autocmd! TerminalOpen * setlocal textwidth=0
augroup END

" spell {{{2
augroup rc_spell
  autocmd! FileType markdown,tex,gitcommit setlocal spell
augroup END

" compile {{{2
augroup rc_compile
  if exists('g:lilypond_enabled') && g:lilypond_enabled
    autocmd! FileType lilypond nmap <silent> <buffer> <LocalLeader>ll :!lilypond %<CR>
  endif
augroup END

" autoindent {{{2
augroup rc_autoindent
  autocmd! FileType c,cpp,cuda,objc,objcpp,go,java,javascript,rust,typescript
        \ setlocal cindent cinoptions=t0,(0,u0,U1,w1,Ws,m1
augroup END

" indentation unit {{{2
" Set filetype specific indentation unit, i.e., shiftwidth. To use tab as the
" indentation unit, set shiftwidth=0 and noexpandtab. A nonzero shiftwidth and
" noexpandtab will give hideous mixed indents (unless shiftwidth happens to equal
" tabstop, but editing behavior should not depend on a display setting like tabstop).
augroup rc_indentunit
  autocmd! FileType vim,sh,javascript,typescript,tex,bib setlocal shiftwidth=2 expandtab
  autocmd! FileType c,cpp,cuda,go setlocal shiftwidth=0 noexpandtab
  autocmd! FileType java,rust setlocal shiftwidth=4 expandtab
augroup END

" folding {{{2
augroup rc_fold
  autocmd! FileType c,cpp,cuda,objc,objcpp,cs,go,java,javascript,rust,typescript
        \ setlocal foldmethod=syntax foldnestmax=2
  autocmd! FileType julia setlocal foldmethod=syntax foldnestmax=2
augroup END
