" vim: foldmethod=marker

set nocompatible              " Be iMproved
let mapleader = ','           " Set <Leader>

" Plugin configuration {{{1

" Download vim-plug if not installed
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif

call plug#begin('~/.vim/plugged')

" tpope-suite {{{2
" Load sensible first, so options can be overridden
Plug 'tpope/vim-sensible'
runtime! plugin/sensible.vim

Plug 'tpope/vim-endwise'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-eunuch'

" dirvish {{{2
Plug 'justinmk/vim-dirvish' | Plug 'kristijanhusak/vim-dirvish-git'

" Git integration {{{2
Plug 'tpope/vim-fugitive' | Plug 'gregsexton/gitv', {'on': ['Gitv']}
Plug 'airblade/vim-gitgutter'
let g:gitgutter_map_keys = 0
nmap <silent> <Leader>gg :Gstatus<CR>
nmap <silent> <Leader>gd :Gdiff<CR>
nmap <silent> <Leader>gv :Gitv<CR>
nmap <silent> <Leader>gV :Gitv!<CR>
nmap <silent> <Leader>gP <Plug>GitGutterPreviewHunk
nmap <silent> <Leader>gs <Plug>GitGutterStageHunk
nmap <silent> <Leader>gu <Plug>GitGutterUndoHunk
nmap <silent> <Leader>gn <Plug>GitGutterNextHunk
nmap <silent> <Leader>gp <Plug>GitGutterPrevHunk

" undotree {{{2
Plug 'mbbill/undotree'
nmap <silent> <Leader>u :UndotreeToggle<CR>

" vim-grepper {{{2
Plug 'mhinz/vim-grepper'
nmap gs <plug>(GrepperOperator)
xmap gs <plug>(GrepperOperator)

" command-t {{{2
Plug 'wincent/command-t',
      \ {'do': 'cd ruby/command-t/ext/command-t && ruby extconf.rb && make'}
nmap <silent> <C-t> <Plug>(CommandT)
nmap <silent> <C-b> <Plug>(CommandTBuffer)
" tmux compatibility:
if !empty($TMUX)
  let g:CommandTSelectNextMap = ['<C-n>', '<C-j>', '<Down>', '<ESC>OB']
  let g:CommandTSelectPrevMap = ['<C-p>', '<C-k>', '<Up>', '<ESC>OA']
  let g:CommandTSelectLeftMap = ['<Left>', '<C-h>', '<ESC>OD']
  let g:CommandTSelectRightMap = ['<Right>', '<C-l>', '<ESC>OC']
endif

" Smart-Tabs {{{2
Plug 'vim-scripts/Smart-Tabs', {'for': ['c', 'cpp', 'objc', 'objcpp', 'cs']}

" loupe {{{2
Plug 'wincent/loupe'
nmap <silent> <Leader><Space> <Plug>(LoupeClearHighlight)

" tcomment {{{2
Plug 'tomtom/tcomment_vim'
let g:tcomment_mapleader1 = "<C-/>"
let g:tcomment_mapleader2 = "g/"
let g:tcomment#options = {'whitespace' : 'no'}

" snippets {{{2
Plug 'SirVer/ultisnips' | Plug 'honza/vim-snippets'
let g:UltiSnipsExpandTrigger = '<C-j>'

" YouCompleteMe {{{2
Plug 'Valloric/YouCompleteMe',
      \ {'do': './install.py --clang-completer > ~/ycm.log'}
let g:ycm_autoclose_preview_window_after_insertion = 1
let g:ycm_goto_buffer_command = 'split-or-existing-window'

augroup ycm-mappings
  autocmd!
  autocmd FileType
        \ c,cpp,objc,objcpp,cuda,cs,go,java,javascript,python,rust,typescript
        \ nmap <silent> <buffer>go :YcmCompleter GoTo<Cr>
  autocmd FileType
        \ c,cpp,objc,objcpp,cuda,cs,java,javascript,python,typescript,rust
        \ nmap <silent> <buffer>K :YcmCompleter GetDoc<Cr>
augroup END

" vim-stay {{{2
Plug 'zhimsel/vim-stay'

" FastFold {{{2
Plug 'Konfekt/FastFold'

" SimpylFold {{{2
Plug 'tmhedberg/SimpylFold'
"augroup SimpylFold
"  autocmd!
"  autocmd BufWinEnter *.py setlocal foldexpr=SimpylFold(v:lnum) foldmethod=expr
"  autocmd BufWinLeave *.py setlocal foldexpr< foldmethod<
"augroup END

" python-pep8-indent {{{2
Plug 'Vimjas/vim-python-pep8-indent'

" Tagbar {{{2
Plug 'majutsushi/tagbar'
let g:tagbar_map_showproto = 'd'
let g:tagbar_map_togglefold = ['o', 'za', '<Space>']
nmap <silent> <Leader>' :TagbarToggle<CR>

" CCTree {{{2
Plug 'hari-rangarajan/CCTree', {'for': ['c', 'cpp', 'java']}

" ALE {{{2
Plug 'w0rp/ale'
let g:ale_echo_msg_error_str = 'E'
let g:ale_echo_msg_info_str = 'I'
let g:ale_echo_msg_warning_str = 'W'
let g:ale_echo_msg_format = '%linter% %severity%: %s (%code%)'

" ListToggle {{{2
Plug 'Valloric/ListToggle'
let g:lt_location_list_toggle_map = '<Leader>el'
let g:lt_quickfix_list_toggle_map = '<Leader>eq'

" vimtex {{{2
Plug 'lervag/vimtex'
let g:vimtex_view_automatic = 0
let g:vimtex_view_method = 'zathura'
let g:vimtex_fold_enabled = 1
let g:vimtex_complete_enabled = 1
let g:vimtex_complete_close_braces = 0
"let g:vimtex_quickfix_latexlog = {
"      \ 'overfull' : 0,
"      \ 'underfull' : 0,
"      \ 'packages' : {
"      \   'default' : 0,
"      \ },
"      \}

" vim-airline {{{2
Plug 'vim-airline/vim-airline' | Plug 'vim-airline/vim-airline-themes'
let g:airline#extensions#tabline#enabled = 1

" vim-slime {{{2
Plug 'jpalardy/vim-slime'
if !empty($TMUX)
  let g:slime_target = "tmux"
  let g:slime_default_config = {
        \ "socket_name": split($TMUX, ",")[0],
        \ "target_pane": ":.1"
        \ }
else
  let g:slime_target = "vimterminal"
  let g:slime_vimterminal_config = {"term_finish": "close"}
endif
let g:slime_paste_file = tempname()
let g:slime_python_ipython = 1
let g:slime_no_mappings = 1
nmap <silent> grip <Plug>SlimeParagraphSend
nmap <silent> grr <Plug>SlimeLineSend
xmap <silent> gr <Plug>SlimeRegionSend

" base16 {{{2
Plug 'chriskempson/base16-vim'

" Currently unused plugins {{{2
"" solarized {{{3
"Plug 'altercation/vim-colors-solarized'

" }}}2

call plug#end()

" Post-plug configuration {{{1

" vim-stay {{{2
set viewoptions=cursor,slash,unix " Set persistence options used by vim-stay

" vimtex {{{2
if !exists('g:ycm_semantic_triggers')
  let g:ycm_semantic_triggers = {}
endif
let g:ycm_semantic_triggers.tex = g:vimtex#re#youcompleteme

" colorscheme {{{2
"colorscheme solarized | call togglebg#map("<F5>")
"let g:airline_theme='solarized'
if filereadable(expand("~/.vimrc_background"))
  let base16colorspace=256
  source ~/.vimrc_background
else
  colorscheme base16-default-dark
endif
let g:airline_theme='base16'

" General settings {{{1

set autowrite            " Save before commands like :next and :make
set hidden               " Keep abandoned buffers around in the background
set noswapfile           " Do not use swap file
set wildmode=longest:full " Set autocomplete command behavior
set mouse=a              " Enable mouse usage (all modes)
set completeopt=menuone,preview " Set completion options
set showcmd              " Show number of selected lines ++ in the bottom line

" Enable persistent undo
set undofile
set undolevels=1000
set undoreload=10000
set undodir=$HOME/.vim/undo
if !isdirectory(&undodir)
  call mkdir(&undodir)
endif

" Editing behavior
set copyindent           " Don't replace tabs with spaces when copying indent
set preserveindent       " Don't replace tabs with spaces when adjusting indent
set expandtab            " Expand tabs as spaces
set shiftwidth=4         " Set width of autoindentation
set textwidth=79         " Auto-format, e.g., gq, wraps here (0: disable)
set nojoinspaces         " Don't have <S-J> (joining) insert double spaces.
set formatoptions=cql1j  " Set auto-format options
augroup autoformat       " Bring out the big guns to override ftplugins
  autocmd!
  autocmd FileType * set fo-=r fo-=o
augroup END


" Search behavior
set ignorecase           " Do case insensitive matching
set smartcase            " Do smart case matching
set hlsearch             " Highlight search

" Always start a server
if empty(v:servername) && exists('*remote_startserver')
  call remote_startserver('VIM')
endif

" Display settings {{{1

set nowrap               " Do not wrap lines for display
set linebreak            " If turning wrap back on, wrap at a whitespace
set relativenumber       " Show relative line numbers
set number               " Show line numbers (relative + absolute => hybrid)
set colorcolumn=80,81,82 " Highlight column 80-82
set showmatch            " Show matching brackets.
set tabstop=4            " Set width of tabstops

" Set whitespace characters in list mode
set listchars=eol:$,tab:\|\ ,trail:-,space:.,extends:>,precedes:<,conceal:*,nbsp:~

" Configure defaults for built-in terminal
set termwinsize=10x0
augroup terminal
  autocmd!
  " Terminal has absolutely no business on the buffer list
  autocmd TerminalOpen * setlocal nobuflisted
augroup END

" Set gui specific options
if has('vim_starting') && has('gui_running')
  set guifont=Noto\ Mono\ 11
  set guioptions+=f        " Dont detach from shell
  set guioptions+=P        " Enable autoselect using the "+-register
  set guioptions-=a        " Disable autoselect using the "*-register
  set guioptions-=T        " Disable toolbar
  set guioptions-=m        " Disable menubar
  set guioptions-=r        " Disable scrollbar
endif

" Key mappings and commands {{{1

" Scroll screen-based instead of line-based
nnoremap k gk
vnoremap k gk
nnoremap j gj
vnoremap j gj
nnoremap gk k
vnoremap gk k
nnoremap gj j
vnoremap gj j

" Navigate windows easily; <Leader> as <C-W>. See :h opening-window.
nnoremap <Leader>s <C-W>s
nnoremap <Leader>v <C-W>v
nnoremap <Leader>n <C-W>n
nnoremap <Leader>^ <C-W>^
nnoremap <Leader>q <C-W>q
nnoremap <Leader>c <C-W>c
nnoremap <Leader>o <C-W>o
nnoremap <Leader><Down> <C-W><Down>
nnoremap <Leader><Up> <C-W><Up>
nnoremap <Leader><Left> <C-W><Left>
nnoremap <Leader><Right> <C-W><Right>
nnoremap <Leader>j <C-W>j
nnoremap <Leader>k <C-W>k
nnoremap <Leader>h <C-W>h
nnoremap <Leader>l <C-W>l
nnoremap <Leader><BS> <C-W><BS>
nnoremap <Leader>w <C-W>w
nnoremap <Leader>W <C-W>W
nnoremap <Leader>t <C-W>t
nnoremap <Leader>b <C-W>b
nnoremap <Leader>p <C-W>p
nnoremap <Leader>P <C-W>P
nnoremap <Leader>r <C-W>r
nnoremap <Leader>R <C-W>R
nnoremap <Leader>x <C-W>x
nnoremap <Leader>K <C-W>K
nnoremap <Leader>J <C-W>J
nnoremap <Leader>H <C-W>H
nnoremap <Leader>L <C-W>L
nnoremap <Leader>T <C-W>T
nnoremap <Leader>= <C-W>=
nnoremap <Leader>- <C-W>-
nnoremap <Leader>+ <C-W>+
nnoremap <Leader>_ <C-W>_
nnoremap <Leader>< <C-W><
nnoremap <Leader>> <C-W>>
nnoremap <Leader><Bar> <C-W><Bar>
nnoremap <Leader>f <C-W>f
nnoremap <Leader>F <C-W>F
nnoremap <Leader>z <C-W>z

" Navigate buffers easily
function! <SID>Bufgo(bang, bufindex, args)
  execute a:bufindex . 'buffer' . a:bang a:args
endfunction

function! <SID>SplitBufgo(bang, bufindex, args)
  execute a:bufindex . 'sbuffer' . a:bang a:args
endfunction

function! <SID>Buflast()
  return <SID>BufNFromIndexWithRef(0, -1, bufnr("$"), bufnr('%'))
endfunction

function! <SID>Buffirst()
  return <SID>BufNFromIndexWithRef(0, 1, 1, bufnr('%'))
endfunction

function! <SID>Bufnext(N)
  return <SID>BufNFromIndexWithRef(a:N, 1, bufnr("%"), bufnr('%'))
endfunction

function! <SID>Bufprev(N)
  return <SID>BufNFromIndexWithRef(a:N, -1, bufnr("%"), bufnr('%'))
endfunction

function! <SID>BufNFromIndexWithRef(N, direction, bufindex, refindex)
  if <SID>Validbuf(a:refindex)
    return <SID>BufNFromIndex(
          \ a:N, a:direction, a:bufindex, getbufvar(a:refindex, '&buftype'))
  endif
  return a:refindex
endfunction

function! <SID>BufNFromIndex(N, direction, bufindex, type)
  let lastbuf = bufnr('$')
  let i = -1
  let newindex = a:bufindex
  if <SID>Validbuf(newindex, a:type)
    let i += 1
  endif
  while i < a:N
    let newindex = <SID>Wraparound(newindex + a:direction, lastbuf)
    if <SID>Validbuf(newindex, a:type)
      let i += 1
    elseif newindex == a:bufindex && i == -1
      return -1
    endif
  endwhile
  return newindex
endfunction

function! <SID>Validbuf(bufindex, ...)
  if bufexists(a:bufindex)
    let btype = getbufvar(a:bufindex, '&buftype')
    if a:0 > 0 && a:1 !=# btype
        return 0
    elseif btype ==# ''
      return buflisted(a:bufindex)
    elseif btype ==# 'help'
      return !buflisted(a:bufindex)
    endif
  endif
  return 0
endfunction

function! <SID>Wraparound(index, length)
  return (a:index + a:length - 1) % a:length + 1
endfunction

function! <SID>Bufremove(cmd, bang, range, line1, line2, ...)
  if a:0 > 0
    if a:range > 0
      " Inconsistent arguments, give up
      let buflist = []
    else
      let buflist = copy(a:000)
    endif
  elseif a:range == 2
    let buflist = range(a:line1,a:line2)
  else
    let buflist = [a:line1]
  endif
  call map(buflist, function('<SID>BufindexMap'))
  call filter(buflist, function('<SID>BufindexFilter'))
  if len(buflist) == 0
    let verb = <SID>BufremoveVerb(a:cmd)
    echohl ErrorMsg
    echomsg "No buffers were" verb
    echohl None
    return
  endif
  for bufindex in buflist
    call <SID>BufremoveIndex(a:cmd, a:bang, bufindex)
  endfor
endfunction

function! <SID>BufremoveIndex(cmd, bang, bufindex)
  " Try to switch buffer in all windows where buffer to remove is open
  let thiswinid = win_getid(winnr())
  for winid in win_findbuf(a:bufindex)
    call win_gotoid(winid)
    execute 'Bnext' . a:bang
  endfor
  call win_gotoid(thiswinid)
  " Buffer might have self-destructed upon being hidden
  if <SID>Bufremovable(a:cmd, a:bufindex)
    execute a:bufindex . a:cmd . a:bang
  endif
endfunction

function! <SID>BufindexMap(_, str)
  if <SID>StringIsNr(a:str)
    return bufnr(str2nr(a:str))
  else
    return bufnr(a:str)
  endif
endfunction

function! <SID>BufindexFilter(_, bufindex)
  if a:bufindex == -1
    return 0
  endif
  return 1
endfunction

function! <SID>StringIsNr(str)
  return (a:str =~# '\m^\d\+$')
endfunction

function! <SID>BufremoveVerb(cmd)
  if a:cmd =~# 'bw'
    return "wiped out"
  elseif a:cmd =~# 'bd'
    return "deleted"
  elseif a:cmd =~# 'bun'
    return "unloaded"
  endif
  return "removed"
endfunction

function! <SID>Bufremovable(cmd, bufindex)
  if bufexists(a:bufindex)
    if a:cmd =~# 'bw'
      return 1
    else
      let loaded = bufloaded(a:bufindex)
      let listed = buflisted(a:bufindex)
      if a:cmd =~# 'bd'
        return (loaded || listed)
      elseif a:cmd =~# 'bun'
        return loaded
      endif
    endif
  endif
  return 0
endfunction

command! -nargs=* -bang Blast
      \ call <SID>Bufgo('<bang>', <SID>Buflast(), <q-args>)
command! -nargs=* -bang SBlast
      \ call <SID>SplitBufgo('<bang>', <SID>Buflast(), <q-args>)
command! -nargs=* -bang Bfirst
      \ call <SID>Bufgo('<bang>', <SID>Buffirst(), <q-args>)
command! -nargs=* -bang SBfirst
      \ call <SID>SplitBufgo('<bang>', <SID>Buffirst(), <q-args>)
command! -nargs=* -bang Brewind Bfirst<bang> <q-args>
command! -nargs=* -bang SBrewind SBfirst<bang> <q-args>
command! -nargs=* -range=1 -bang Bnext
      \ call <SID>Bufgo('<bang>', <SID>Bufnext(<count>), <q-args>)
command! -nargs=* -range=1 -bang SBnext
      \ call <SID>SplitBufgo('<bang>', <SID>Bufnext(<count>), <q-args>)
command! -nargs=* -range=1 -bang Bprev
      \ call <SID>Bufgo('<bang>', <SID>Bufprev(<count>), <q-args>)
command! -nargs=* -range=1 -bang SBprev
      \ call <SID>SplitBufgo('<bang>', <SID>Bufprev(<count>), <q-args>)
command! -nargs=* -range=1 -bang BNext <count>Bprev<bang> <q-args>
command! -nargs=* -range=1 -bang SBNext <count>SBprev<bang> <q-args>
command! -nargs=* -complete=buffer -range -addr=buffers -bang Bdelete
      \ call <SID>Bufremove(
      \ 'bdelete', '<bang>', <range>, <line1>, <line2>, <f-args>)
command! -nargs=* -complete=buffer -range -addr=buffers -bang Bwipeout
      \ call <SID>Bufremove(
      \ 'bwipeout', '<bang>', <range>, <line1>, <line2>, <f-args>)
command! -nargs=* -complete=buffer -range -addr=buffers -bang Bunload
      \ call <SID>Bufremove(
      \ 'bunload', '<bang>', <range>, <line1>, <line2>, <f-args>)

nmap <silent> <Down> :Blast<CR>
nmap <silent> <Up> :Bfirst<CR>
nmap <silent> <Left> :Bprev<CR>
nmap <silent> <Right> :Bnext<CR>
nmap <silent> <C-c> :Bdelete<CR>

" Define a command that opens a file like :drop, but splits the window if the
" buffer in focus is of a special buftype to avoid displacing it.
function! Drop(args)
  let bufindex = bufnr('%')
  let btype = getbufvar(bufindex, '&buftype')
  let special = (btype !=# "")
  if special
    " Trick vim into refusing to abandon the buffer in focus
    let hid = getbufvar(bufindex, '&hidden')
    let mod = getbufvar(bufindex, '&modified')
    call setbufvar(bufindex, '&hidden', 0)
    call setbufvar(bufindex, '&buftype', "")
    call setbufvar(bufindex, '&modified', 1)
  endif
  execute 'drop' a:args
  if special
    " Reset buffer options
    call setbufvar(bufindex, '&modified', mod)
    call setbufvar(bufindex, '&buftype', btype)
    call setbufvar(bufindex, '&hidden', hid)
  endif
endfunction

command! -nargs=+ -complete=file Drop call Drop(<q-args>)

" Hit <Leader>, to Drop $MYVIMRC, and <Leader>. to source
nmap <silent> <Leader>, :Drop $MYVIMRC<CR>
if has('gui_running') && filereadable($MYGVIMRC)
    nmap <silent> <Leader>. :source $MYVIMRC<CR>:source $MYGVIMRC<CR>
else
    nmap <silent> <Leader>. :source $MYVIMRC<CR>
endif

" Toggle folds with <Space>
nnoremap <expr> <Space>
      \ foldlevel('.') ?
      \ 'za' :
      \ "\<Space>"

" Hit <Leader>/ to toggle list mode
nmap <silent> <Leader>\ :set list!<CR>

" Change the (local) directory to that of current file with :Cd (:Lcd)
command! Cd cd %:h
command! Lcd lcd %:h

" Available unmodified keys to follow leader: imy;/[]0123456789`

" Filetype specific settings {{{1

" tex {{{2
"let g:tex_flavor = 'latex'  " Let's see if leaving this out works

augroup tex
  autocmd!
  autocmd FileType tex,bib setlocal tabstop=2 shiftwidth=2 textwidth=0 wrap
        \ breakindent breakindentopt=shift:2
  autocmd FileType tex setlocal spell
augroup END

" lilypond {{{2
let g:lilypond_vim_dir = split(expand('/usr/share/lilypond/*/vim/'))[-1]
if isdirectory(g:lilypond_vim_dir)
  filetype off
  set rtp+=g:lilypond_vim_dir
  filetype on
endif

augroup lilypond
  autocmd!
  autocmd FileType lilypond setlocal tabstop=2 shiftwidth=2
  autocmd FileType lilypond
        \ nmap <silent> <buffer> <LocalLeader>ly :!lilypond %<CR>
augroup END

" gitcommit {{{2
augroup gitcommit
  autocmd!
  autocmd FileType gitcommit setlocal spell textwidth=72 formatoptions+=t
augroup END

" script languages {{{2
augroup scripts
  autocmd!
  autocmd FileType vim,javascript,typescript setlocal tabstop=2 shiftwidth=2
augroup END

" c-family {{{2
augroup c_family
  autocmd!
  autocmd FileType c,cpp,objc,objcpp,cuda,cs,go,java setlocal cindent
        \ cinoptions=(0,u0 noexpandtab tabstop=8 shiftwidth=8 foldmethod=syntax
        \ foldnestmax=2
augroup END
